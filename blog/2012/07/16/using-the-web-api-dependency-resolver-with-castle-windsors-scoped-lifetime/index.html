<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="width=device-width" name="viewport" /><title>Using the Web API Dependency Resolver with Castle Windsor&#39;s Scoped Lifetime - Nikos Baxevanis</title><link href="/feed" rel="alternate" type="application/rss+xml" /><link href="/stylesheets/blog.css?1390930234" media="screen" rel="stylesheet" type="text/css" /></head><body><div id="title"><div><a href="/">Nikos Baxevanis</a><span>&nbsp;-&nbsp;</span><a href="/blog">Blog</a><span>&nbsp;-&nbsp;</span><a href="/#about">About</a></div><div class="line"></div></div><div id="main"><div id="content"><div class="post"><h2>Using the Web API Dependency Resolver with Castle Windsor&#39;s Scoped Lifetime</h2><div class="undertitle"><span class="meta">by Nikos Baxevanis in </span><a class="tag" href="/blog/#web-api">web-api</a><a class="tag" href="/blog/#castle-windsor">castle-windsor</a></div><div class="content"><p><strong>Update</strong>: <a href="http://blog.ploeh.dk/">Mark Seemann</a> has provided a <a href="http://blog.ploeh.dk/2012/10/03/DependencyInjectionInASPNETWebAPIWithCastleWindsor.aspx">solution</a> without using the IDependencyResolver interface.</p>

<blockquote>
<p>This post is the result of a very good <a href="http://nikosbaxevanis.com/2012/06/04/using-the-web-api-dependency-resolver-with-castle-windsor-part-2/#comment-568630441">suggestion</a> in the comments section of the <a href="http://nikosbaxevanis.com/2012/06/04/using-the-web-api-dependency-resolver-with-castle-windsor-part-2">previous</a> post.</p>
</blockquote>

<p>The WindsorDependencyScope from the previous post has been modified to use the Scoped lifetime <a href="http://docs.castleproject.org/Windsor.Whats-New-In-Windsor-3.ashx#Added_two_new_lifestyles:_scoped_and_bound_2">available</a> in Castle Windsor 3.</p>

<pre><code class="c#">using System;
using System.Collections.Generic;
using System.Linq;
using System.Web.Http.Dependencies;
using Castle.MicroKernel.Lifestyle;
using Castle.Windsor;

internal sealed class WindsorDependencyScope : IDependencyScope
{
    private readonly IWindsorContainer container;
    private readonly IDisposable scope;

    public WindsorDependencyScope(IWindsorContainer container)
    {
        if (container == null)
        {
            throw new ArgumentNullException(&quot;container&quot;);
        }

        this.container = container;
        this.scope = container.BeginScope();
    }

    public object GetService(Type t)
    {
        return this.container.Kernel.HasComponent(t) ? this.container.Resolve(t) : null;
    }

    public IEnumerable&lt;object&gt; GetServices(Type t)
    {
        return this.container.ResolveAll(t).Cast&lt;object&gt;().ToArray();
    }

    public void Dispose()
    {
        this.scope.Dispose();
    }
}
</code></pre>

<p>The <code>BeginScope</code> is an extension method for the <code>IWindsorContainer</code> type. It returns by default an instance of a <code>CallContextLifetimeScope</code> type. It uses the <a href="http://msdn.microsoft.com/en-us/library/system.runtime.remoting.messaging.callcontext.aspx">Call Context</a> so it can be associated with thread pool threads and manually created threads within a <em>single</em> AppDomain (it does not use the <em>Logical</em> Call Context).</p>

<p>On each request the Web API calls the <a href="http://aspnetwebstack.codeplex.com/SourceControl/changeset/view/a1b7c04f7227#src%2fSystem.Web.Http%2fHttpRequestMessageExtensions.cs">GetDependencyScope</a> extension method of the <a href="http://msdn.microsoft.com/en-us/library/system.net.http.httprequestmessage.aspx">HttpRequestMessage</a> type, which, in return, calls it&#39;s own <a href="http://aspnetwebstack.codeplex.com/SourceControl/changeset/view/a1b7c04f7227#src%2fSystem.Web.Http%2fDependencies%2fIDependencyResolver.cs">BeginScope</a> method to start a new resolution scope. Using our own implementation of the <a href="http://aspnetwebstack.codeplex.com/SourceControl/changeset/view/a1b7c04f7227#src%2fSystem.Web.Http%2fDependencies%2fIDependencyResolver.cs">IDependencyResolver</a> interface we always return a new instance of the WindsorDependencyScope type.</p>

<pre><code class="c#">internal sealed class WindsorDependencyResolver : IDependencyResolver
{    
    // &#39;using&#39; Directives and other type members removed for brevity.

    public IDependencyScope BeginScope()
    {
        return new WindsorDependencyScope(this.container);
    }
}
</code></pre>

<p>Since we use the Scoped lifetime we need to define it also in the registration code. Then, we will always have at most one instance of each requested type per resolution scope (that is, a request).</p>

<pre><code class="c#">internal sealed class WebWindsorInstaller : IWindsorInstaller
{
    public void Install(IWindsorContainer container, IConfigurationStore store)
    {
        container.Register(Classes
            .FromAssemblyContaining&lt;ValuesController&gt;()
            .BasedOn&lt;IHttpController&gt;()
            .LifestyleScoped());
    }
}
</code></pre>

<p>The source code can be found <a href="http://nikosbaxevanis.com/downloads/WebApiScopedLifetimeDependencyResolverSample.zip">here</a>.</p>
</div></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname = 'bonusbits';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script></div></div></body><div id="side"><img src="/images/nikos-baxevanis-small.png" alt="Nikos Baxevanis" title="Nikos Baxevanis"></div><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-24262928-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></html>