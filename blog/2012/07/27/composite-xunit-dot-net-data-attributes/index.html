<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="width=device-width" name="viewport" /><title>Composite xUnit.net Data Attributes</title><link href="/images/favicon.ico" rel="icon" type="image/x-icon" /><link href="/feed" rel="alternate" type="application/rss+xml" /><link href="/stylesheets/blog.css?1388706841" media="screen" rel="stylesheet" type="text/css" /></head><body><body><div id="title"><div><h1><a href="/blog" style="color: #222">moodmosaic</a></h1><div><span>by </span><a href="/">Nikos Baxevanis </a><a href="http://creativecommons.org/licenses/by/3.0/" style="color: #877">(license)</a></div></div><div class="line"></div></div><div id="full"><h1><a>Composite xUnit.net Data Attributes</a></h1><div class="undertitle"><span class="date">Filed under </span><a class="tag" href="/blog#xunit.net">xunit.net</a><a class="tag" href="/blog#unit-testing">unit-testing</a></div><p><a href="http://xunit.codeplex.com/">xUnit.net</a> <a href="http://nuget.org/packages/xunit.extensions">extensions</a> support data-driven tests called <a href="http://xunit.codeplex.com/wikipage?title=Comparisons#note4">Theories</a>. Such tests are similar to regular xUnit.net tests but instead of being decorated with <code>[Fact]</code> they are decorated with <code>[Theory]</code>.</p>

<p>Below is a data-driven test with the data coming a Microsoft Excel (.xls) spreadsheet.</p>

<pre><code class="c#">[Theory]
[ExcelData(&quot;UnitTestData.xls&quot;, &quot;SELECT x, y FROM Data&quot;)]
public void Foo(object x, object y)
{
    // &#39;x&#39; and &#39;y&#39; are values from the .xls spreadsheet.
}
</code></pre>

<p>Also, a data-driven test with the data coming from a type implementing the IEnumerable<object[]>.</p>

<pre><code class="c#">[Theory]
[ClassData(typeof(CollectionOfSpecifiedString))]
public void Bar(object x, object y)
{
    // &#39;x&#39; and &#39;y&#39; are values from the IEnumerable&lt;object[]&gt; type.
}

internal class CollectionOfSpecifiedString : IEnumerable&lt;object[]&gt;
{
    public IEnumerator&lt;object[]&gt; GetEnumerator()
    {
        yield return new object[]
        {
            &quot;foo&quot;, &quot;zoo&quot;
        };
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return this.GetEnumerator();
    }
}
</code></pre>

<p>In the above samples, <code>[ExcelData]</code> and <code>[ClassData]</code> are attributes representing a data source for a data-driven test.</p>

<p><strong>Using data from multiple attributes</strong></p>

<p>Below is a data-driven test with the data coming from a type implementing the IEnumerable<object[]> combined with the data coming from an .xls spreadsheet.</p>

<pre><code class="c#">[Theory]
[ClassExcelData(
    typeof(CollectionOfSpecifiedString),
    &quot;UnitTestData.xls&quot;, &quot;SELECT x, y FROM Data&quot;)]
public void Zoo(object x, object y)
{
    // &#39;x&#39; is coming from the IEnumerable&lt;object[]&gt; type.
    // &#39;y&#39; is coming from the .xls spreadsheet.
}

internal class CollectionOfSpecifiedString : IEnumerable&lt;object[]&gt;
{
    public IEnumerator&lt;object[]&gt; GetEnumerator()
    {
        yield return new object[]
        {
            &quot;foo&quot;
        };
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return this.GetEnumerator();
    }
}
</code></pre>

<p><strong>Creating a composite attribute</strong></p>

<p>The <code>[ClassExcelData]</code> from the previous example is a <a href="http://en.wikipedia.org/wiki/Composite_pattern">composite</a> of two xUnit.net&#39;s data attributes <code>[ClassData]</code> and <code>[ExcelData]</code>.</p>

<p>All we have to do is create a type deriving from <code>CompositeDataAttribute</code>, passing in its base constructor an array of the data attributes we would like to compose.</p>

<pre><code class="c#">[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
internal class ClassExcelDataAttribute : CompositeDataAttribute
{
    internal ClassExcelDataAttribute(Type type, string filename, string selectStatement)
        : base(new DataAttribute[] { 
                new ClassDataAttribute(type), 
                new ExcelDataAttribute(filename, selectStatement) })
    {
    }
}
</code></pre>

<p>The description for the <code>CompositeDataAttribute</code> algorithm can be found <a href="http://nikosbaxevanis.com/2011/08/25/combining-data-theories-in-autofixture-xunit-extension/">here</a>. </p>

<blockquote>
<p>When defining a composite data attribute, it is acceptable for the first attribute to provide some (or all) data for the parameters of the test method. However, subsequent data attributes must be able to provide the data for the exact position where the previous attribute stopped.</p>
</blockquote>

<p><strong>Obtaining the CompositeDataAttribute class</strong></p>

<p>CompositeDataAttribute is currently bundled with <a href="https://github.com/AutoFixture/AutoFixture">AutoFixture</a> <a href="http://feed.nuget.org/packages/AutoFixture.Xunit">extension</a> for xUnit.net. You can use it by installing the <a href="http://feed.nuget.org/packages/AutoFixture.Xunit">AutoFixture.Xunit NuGet package</a>.</p>
</div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname = 'bonusbits';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script></body><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-24262928-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></body></html>