<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="Programmer using Test-Driven Development, C# and F#. Core Contributor to AutoFixture." name="Description" /><title>Composite xUnit.net Data Attributes</title><link href="/stylesheets/styles.css?1406533649" media="screen" rel="stylesheet" type="text/css" /></head><body><div><div><p><a href="/">Nikos Baxevanis</a></p></div><div><h1>Composite xUnit.net Data Attributes</h1><div>July 27, 2012 |  <a href="/category/xunit.net/">xUnit.net</a> |  <a href="/category/unit-testing/">Unit Testing</a></div></div><div><p><a href="http://xunit.codeplex.com/">xUnit.net</a> <a href="http://nuget.org/packages/xunit.extensions">extensions</a> support data-driven tests called <a href="http://xunit.codeplex.com/wikipage?title=Comparisons#note4">Theories</a>. Such tests are similar to regular xUnit.net tests but instead of being decorated with <code>[Fact]</code> they are decorated with <code>[Theory]</code>.</p>

<p>Below is a data-driven test with the data coming a Microsoft Excel (.xls) spreadsheet.</p>
<pre class="highlight text">[Theory]
[ExcelData(&quot;UnitTestData.xls&quot;, &quot;SELECT x, y FROM Data&quot;)]
public void Foo(object x, object y)
{
    // 'x' and 'y' are values from the .xls spreadsheet.
}
</pre>
<p>Also, a data-driven test with the data coming from a type implementing the IEnumerable<object[]>.</p>
<pre class="highlight text">[Theory]
[ClassData(typeof(CollectionOfSpecifiedString))]
public void Bar(object x, object y)
{
    // 'x' and 'y' are values from the IEnumerable&lt;object[]&gt; type.
}

internal class CollectionOfSpecifiedString : IEnumerable&lt;object[]&gt;
{
    public IEnumerator&lt;object[]&gt; GetEnumerator()
    {
        yield return new object[]
        {
            &quot;foo&quot;, &quot;zoo&quot;
        };
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return this.GetEnumerator();
    }
}
</pre>
<p>In the above samples, <code>[ExcelData]</code> and <code>[ClassData]</code> are attributes representing a data source for a data-driven test.</p>

<p><strong>Using data from multiple attributes</strong></p>

<p>Below is a data-driven test with the data coming from a type implementing the IEnumerable<object[]> combined with the data coming from an .xls spreadsheet.</p>
<pre class="highlight text">[Theory]
[ClassExcelData(
    typeof(CollectionOfSpecifiedString),
    &quot;UnitTestData.xls&quot;, &quot;SELECT x, y FROM Data&quot;)]
public void Zoo(object x, object y)
{
    // 'x' is coming from the IEnumerable&lt;object[]&gt; type.
    // 'y' is coming from the .xls spreadsheet.
}

internal class CollectionOfSpecifiedString : IEnumerable&lt;object[]&gt;
{
    public IEnumerator&lt;object[]&gt; GetEnumerator()
    {
        yield return new object[]
        {
            &quot;foo&quot;
        };
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return this.GetEnumerator();
    }
}
</pre>
<p><strong>Creating a composite attribute</strong></p>

<p>The <code>[ClassExcelData]</code> from the previous example is a <a href="http://en.wikipedia.org/wiki/Composite_pattern">composite</a> of two xUnit.net&#39;s data attributes <code>[ClassData]</code> and <code>[ExcelData]</code>.</p>

<p>All we have to do is create a type deriving from <code>CompositeDataAttribute</code>, passing in its base constructor an array of the data attributes we would like to compose.</p>
<pre class="highlight text">[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
internal class ClassExcelDataAttribute : CompositeDataAttribute
{
    internal ClassExcelDataAttribute(Type type, string filename, string selectStatement)
        : base(new DataAttribute[] { 
                new ClassDataAttribute(type), 
                new ExcelDataAttribute(filename, selectStatement) })
    {
    }
}
</pre>
<p>The description for the <code>CompositeDataAttribute</code> algorithm can be found <a href="http://nikosbaxevanis.com/2011/08/25/combining-data-theories-in-autofixture-xunit-extension/">here</a>. </p>

<blockquote>
<p>When defining a composite data attribute, it is acceptable for the first attribute to provide some (or all) data for the parameters of the test method. However, subsequent data attributes must be able to provide the data for the exact position where the previous attribute stopped.</p>
</blockquote>

<p><strong>Obtaining the CompositeDataAttribute class</strong></p>

<p>CompositeDataAttribute is currently bundled with <a href="https://github.com/AutoFixture/AutoFixture">AutoFixture</a> <a href="http://feed.nuget.org/packages/AutoFixture.Xunit">extension</a> for xUnit.net. You can use it by installing the <a href="http://feed.nuget.org/packages/AutoFixture.Xunit">AutoFixture.Xunit NuGet package</a>.</p>
</div><div><br /><hr />Have feedback on this post? Let <a href="http://twitter.com/nikosbaxevanis" target="_blank">@nikosbaxevanis</a> know on Twitter.</div></div><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-24262928-1']);
_gaq.push(['_trackPageview']);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></body></html>