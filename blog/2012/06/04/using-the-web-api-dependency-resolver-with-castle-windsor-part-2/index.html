<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="Nikos Baxevanis: Full-Stack Programmer working on small as well as big projects using Test-Driven Development, C#, F#, and JavaScript." name="Description" /><title>Using the Web API Dependency Resolver with Castle Windsor (Part 2)</title><link href="/stylesheets/styles.css?1403508151" media="screen" rel="stylesheet" type="text/css" /></head><body><div><div><h1>Using the Web API Dependency Resolver with Castle Windsor (Part 2)</h1><div>June 04, 2012</div></div><div><p><strong>Update</strong>: <a href="http://blog.ploeh.dk/">Mark Seemann</a> has provided a <a href="http://blog.ploeh.dk/2012/10/03/DependencyInjectionInASPNETWebAPIWithCastleWindsor.aspx">solution</a> without using the IDependencyResolver interface.</p>

<blockquote>
<p>The code in this post requires the ASP.NET MVC 4 RC. If you use the Beta version use the code from <a href="http://nikosbaxevanis.com/2012/03/16/using-the-web-api-dependency-resolver-with-castle-windsor/">this</a> post.</p>
</blockquote>

<p>Among the many changes in ASP.NET MVC 4 RC, there is now added support for releasing object graphs, resolved on each request, using dependency scopes.</p>

<p><strong>Creating a dependency scope per request</strong></p>

<p>Since the IHttpControllerFactory interface has been <a href="http://aspnetwebstack.codeplex.com/SourceControl/network/forks/jongalloway/aspnetwebstack/changeset/changes/f6a7f35302ba">removed</a>, the recommendation (from the <a href="http://www.asp.net/whitepapers/mvc4-release-notes#_Toc303253817">release notes</a>) is to use the <a href="http://aspnetwebstack.codeplex.com/SourceControl/changeset/view/a1b7c04f7227#src%2fSystem.Web.Http%2fDispatcher%2fIHttpControllerSelector.cs">IHttpControllerSelector</a> interface to control <a href="http://aspnetwebstack.codeplex.com/SourceControl/changeset/view/a1b7c04f7227#src%2fSystem.Web.Http%2fControllers%2fIHttpController.cs">IHttpController</a> selection and the <a href="http://aspnetwebstack.codeplex.com/SourceControl/changeset/view/a1b7c04f7227#src%2fSystem.Web.Http%2fDispatcher%2fIHttpControllerActivator.cs">IHttpControllerActivator</a> interface to control IHttpController activation.</p>

<p>Below is the IHttpControllerSelector interface:</p>
<pre class="highlight text">public interface IHttpControllerSelector
{
    HttpControllerDescriptor SelectController(HttpRequestMessage request);
}

// Other methods removed for brevity.
</pre>
<p>And the IHttpControllerActivator interface:</p>
<pre class="highlight text">public interface IHttpControllerActivator
{
    IHttpController Create(
        HttpRequestMessage request, 
        HttpControllerDescriptor controllerDescriptor, 
        Type controllerType);
}
</pre>
<p>Both interfaces contain method(s) accepting, among others, an <a href="http://goo.gl/jsUg2">HttpRequestMessage</a>. The trick here is to use the HttpRequestMessage&#39;s extension method <a href="http://aspnetwebstack.codeplex.com/SourceControl/changeset/view/a1b7c04f7227#src%2fSystem.Web.Http%2fHttpRequestMessageExtensions.cs">GetDependencyScope</a> for resolving controllers (instead of using a DI Container directly).</p>

<p>Internally, the GetDependencyScope method uses the DependencyResolver (registered in the GlobalConfiguration instance) calling it&#39;s <a href="http://aspnetwebstack.codeplex.com/SourceControl/changeset/view/a1b7c04f7227#src%2fSystem.Web.Http%2fDependencies%2fIDependencyResolver.cs">BeginScope</a> method which <strong>creates a new resolution scope</strong>. Objects that are resolved in that scope are tracked internally. Once the scope is disposed, those objects are released (using the container&#39;s Release method).</p>

<p>Below is an implementation of the IDependencyScope interface:</p>
<pre class="highlight text">using System;
using System.Collections.Generic;
using System.Linq;
using System.Web.Http.Dependencies;

internal class ReleasingDependencyScope : IDependencyScope
{
    private readonly IDependencyScope scope;
    private readonly Action&lt;object&gt; release;
    private readonly List&lt;object&gt; instances;

    public WindsorDependencyScope(IDependencyScope scope, Action&lt;object&gt; release)
    {
        if (scope == null)
        {
            throw new ArgumentNullException(&quot;scope&quot;);
        }

        if (release == null)
        {
            throw new ArgumentNullException(&quot;release&quot;);
        }

        this.scope = scope;
        this.release = release;
        this.instances = new List&lt;object&gt;();
    }

    public object GetService(Type t)
    {
        object service = this.scope.GetService(t);
        this.AddToScope(service);

        return service;
    }

    public IEnumerable&lt;object&gt; GetServices(Type t)
    {
        var services = this.scope.GetServices(t);
        this.AddToScope(services);

        return services;
    }

    public void Dispose()
    {
        foreach (object instance in this.instances)
        {
            this.release(instance);
        }

        this.instances.Clear();
    }

    private void AddToScope(params object[] services)
    {
        if (services.Any())
        {
            this.instances.AddRange(services);
        }
    }
}
</pre>
<p>Having a custom implementation of the <a href="http://aspnetwebstack.codeplex.com/SourceControl/changeset/view/a1b7c04f7227#src%2fSystem.Web.Http%2fDependencies%2fIDependencyScope.cs">IDependencyScope</a> interface, we can now move on with the implementation of the <a href="http://aspnetwebstack.codeplex.com/SourceControl/changeset/view/a1b7c04f7227#src%2fSystem.Web.Http%2fDependencies%2fIDependencyResolver.cs">IDependencyResolver</a> interface. The recommendation (from the <a href="http://aspnetwebstack.codeplex.com/SourceControl/changeset/view/a1b7c04f7227#src%2fSystem.Web.Http%2fDependencies%2fIDependencyResolver.cs">source code</a>) is to return a new instance of IDependencyScope every time the BeginScope method is called.</p>

<p>An implementation of the IDependencyResolver interface for Castle Windsor could be similar to the one below:</p>
<pre class="highlight text">using System;
using System.Collections.Generic;
using System.Linq;
using System.Web.Http.Dependencies;
using Castle.Windsor;

internal class WindsorDependencyResolver : IDependencyResolver
{
    private readonly IWindsorContainer container;

    public WindsorDependencyResolver(IWindsorContainer container)
    {
        if (container == null)
        {
            throw new ArgumentNullException(&quot;container&quot;);
        }

        this.container = container;
    }

    public object GetService(Type t)
    {
        return this.container.Kernel.HasComponent(t) ? this.container.Resolve(t) : null;
    }

    public IEnumerable&lt;object&gt; GetServices(Type t)
    {
        return this.container.ResolveAll(t).Cast&lt;object&gt;().ToArray();
    }

    public IDependencyScope BeginScope()
    {
        return new ReleasingDependencyScope(this, this.container.Release);
    }

    public void Dispose()
    {
    }
}
</pre>
<p>As we can see, the BeginScope method returns a new instance of IDependencyScope which can resolve and release objects that belong to that scope.</p>

<p>Moving next, when upgrading from Beta to RC there <em>might</em> be another thing to consider. Since the IHttpControllerFactory interface has now been removed, implementations of that interface were using the <em>controllerName</em> in order to resolve component instances from the DI Containers. As a result, controllers were registered in the DI Containers using names for each registration.</p>

<p>To keep the <em>named</em> registrations (and not break compatibility with any JavaScript clients) we can create a <a href="http://aspnetwebstack.codeplex.com/SourceControl/changeset/view/a1b7c04f7227#src%2fSystem.Web.Http%2fDispatcher%2fDefaultHttpControllerSelector.cs">DefaultHttpControllerSelector</a> derived type and override it&#39;s SelectController method. We can then use the DefaultHttpControllerSelector&#39;s GetControllerName method which returns the requested path name <em>(e.g. &ldquo;Orders&rdquo;)</em>. At that point we can map that name to an <a href="http://aspnetwebstack.codeplex.com/SourceControl/changeset/view/a1b7c04f7227#src%2fSystem.Web.Http%2fApiController.cs">ApiController</a> derived type <em>(ex.: OrderController)</em>.</p>

<p>A DefaultHttpControllerSelector derived type could be similar to the one below:</p>
<pre class="highlight text">using System;
using System.Linq;
using System.Net.Http;
using System.Reflection;
using System.Web.Http;
using System.Web.Http.Controllers;
using System.Web.Http.Dispatcher;

internal class PluralizedNameHttpControllerSelector : DefaultHttpControllerSelector
{
    private readonly HttpConfiguration configuration;
    private readonly Assembly controllerAssembly;

    public PluralizedNameHttpControllerSelector(
        HttpConfiguration configuration, Assembly controllerAssembly)
        : base(configuration)
    {
        if (configuration == null)
        {
            throw new ArgumentNullException(&quot;configuration&quot;);
        }

        if (controllerAssembly == null)
        {
            throw new ArgumentNullException(&quot;controllerAssembly&quot;);
        }

        this.configuration = configuration;
        this.controllerAssembly = controllerAssembly;
    }

    public override HttpControllerDescriptor SelectController(
        HttpRequestMessage request)
    {
        var controllerName = base.GetControllerName(request);
        var controllerType = this.GetControllerType(controllerName);

        return new HttpControllerDescriptor(
            this.configuration, controllerName, controllerType);
    }

    private Type GetControllerType(string name)
    {
        // Look in 'this.controllerAssembly' and find the types that can be
        // assigned from an instance of IHttpController  and return the one
        // whose name matches with the given name.
    }
}
</pre>
<blockquote>
<p>Make sure to register the above type in Castle Windsor otherwise the framework will pick it&#39;s default implementation.</p>
</blockquote>

<p>All the above information is the result of browsing the source code on CodePlex. If any  articles or blog posts are released (by the ASP.NET team or individuals) I might create a new post with updates, if necessary.</p>
</div><div><hr /><small>Published in <a href="/category/web-api/">Web API</a>, <a href="/category/castle-windsor/">Castle Windsor</a>, by <a href="/">Nikos Baxevanis</a>.</small></div></div><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-24262928-1']);
_gaq.push(['_trackPageview']);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></body></html>