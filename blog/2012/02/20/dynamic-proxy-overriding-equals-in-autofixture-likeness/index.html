<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="width=device-width" name="viewport" /><title>Dynamic Proxy overriding Equals in AutoFixture Likeness</title><link href="/images/favicon.ico" rel="icon" type="image/x-icon" /><link href="/feed" rel="alternate" type="application/rss+xml" /><link href="/stylesheets/blog.css?1388779989" media="screen" rel="stylesheet" type="text/css" /></head><body><body><div id="title"><div><h1><a href="/blog" style="color: #222">moodmosaic</a></h1><div><span>by </span><a href="/">Nikos Baxevanis </a><a href="http://creativecommons.org/licenses/by/3.0/" style="color: #877">(license)</a></div></div><div class="line"></div></div><div id="full"><h1><a>Dynamic Proxy overriding Equals in AutoFixture Likeness</a></h1><div class="undertitle"><span class="date">Filed under </span><a class="tag" href="/blog#autofixture">autofixture</a></div><p>From version 2.9.0 of AutoFixture, the&nbsp;<a href="http://blog.ploeh.dk/2010/06/29/IntroducingAutoFixtureLikeness.aspx" target="_blank">Likeness</a>&nbsp;class contains a new feature for&nbsp;creating a dynamic proxy that overrides Equals on the destination type.</p>

<p>As an example, we want to compare instances of the following types:</p>

<pre><code class="c#">public class DoubleParameterType&lt;T1, T2&gt;
{
    public DoubleParameterType(T1 parameter1, T2 parameter2)
    {
        this.Parameter1 = parameter1;
        this.Parameter2 = parameter2;
    }

    public T1 Parameter1 { get; private set; }
    public T2 Parameter2 { get; private set; }
}

public class SingleParameterType&lt;T&gt;
{
    public SingleParameterType(T parameter)
    {
        this.Parameter = parameter;
    }

    public T Parameter { get; private set; }
}
</code></pre>

<p>We can have the following syntax (prior to version 2.9.0):</p>

<pre><code class="c#">[Fact]
public void TestWithLikeness()
{
    // Fixture setup
    var value = new DoubleParameterType&lt;int, double&gt;(1, 2.0);

    Likeness&lt;DoubleParameterType&lt;int, double&gt;, SingleParameterType&lt;int&gt;&gt; sut 
        = value.AsSource()
               .OfLikeness&lt;SingleParameterType&lt;int&gt;&gt;();

    // Exercise system
    var result = sut.Equals(value);
    // Verify outcome
    Assert.True(result);
}
</code></pre>

<p>However, from version 2.9.0 there is also a new CreateProxy method on Likeness which returns a proxy of the destination type overriding Equals with Likeness&rsquo;s instance of IEqualityComparer&nbsp;(the SemanticComparer class):</p>

<pre><code class="c#">[Fact]
public void TestWithLikenessProxy()
{
    // Fixture setup
    var value = new DoubleParameterType&lt;int, double&gt;(1, 2.0);

    SingleParameterType&lt;int&gt; sut
        = value.AsSource()
               .OfLikeness&lt;SingleParameterType&lt;int&gt;&gt;()
               .CreateProxy();

    // Exercise system
    var result = sut.Equals(value);
    // Verify outcome
    Assert.True(result);
}
</code></pre>

<p>Below is also an example, where we need to verify that an expectation was met:</p>

<pre><code class="c#">public class Bar
{
    public string Zip { get; set; }
}

public class Foo
{
    public Bar Bar { get; private set; }

    public void DoSomething(ISomeContext ctx)
    {
        this.Bar = new Bar { Zip = &quot;12345&quot; };
        ctx.DoSomething(this.Bar);
    }
}

public interface ISomeContext
{
    void DoSomething(object request);
}

[Fact]
public void Test()
{
    var foo = new Foo();
    var ctx = new Mock&lt;ISomeContext&gt;();
    foo.DoSomething(ctx.Object);

    var bar = new Bar().AsSource().OfLikeness&lt;Bar&gt;().CreateProxy();
    bar.Zip = &quot;12345&quot;;

    ctx.Verify(x =&gt; x.DoSomething(bar));
}
</code></pre>

<p>Although the new Bar instance is created inside the DoSomething method, we can pass a <em>proxied </em>Bar instance on the mock&rsquo;s Verify method.</p>

<p>Internally, a custom Proxy Generator was written which also&nbsp;supports types with non-parameterless constructors.&nbsp;In order to create proxies of such types, the values from the source have to be compatible with the parameters on the destination constructor.&nbsp;(The mapping between the two is made possible by using the same semantic heuristics, as the default semantic comparison.)</p>
</div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname = 'bonusbits';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script></body><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-24262928-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></body></html>