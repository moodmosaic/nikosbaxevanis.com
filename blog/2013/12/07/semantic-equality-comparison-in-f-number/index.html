<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="Nikos Baxevanis: Full-stack programmer working on small as well as big projects using test-driven development." name="Description" /><title>Semantic Equality Comparison in F#</title><link href="/stylesheets/styles.css?1402919787" media="screen" rel="stylesheet" type="text/css" /></head><body><div><div><h1>Semantic Equality Comparison in F#</h1><div>December 07, 2013</div></div><div><p>This post demonstrates a way to perform semantic equality for complex object graphs with <a href="https://github.com/AutoFixture/AutoFixture/blob/master/Src/SemanticComparison/SemanticComparer.cs#L175">SemanticComparer</a> including Structural Types, Entities, Value Objects, as well as Primitive Types.</p>

<p><strong>Scenario</strong></p>

<p>The equality algorithm for <code>ComplexType</code> should use the default equality for <code>record</code>, <code>number</code>, <code>text</code>, <code>version</code> and <code>value</code>, while it should use custom equality for <code>os</code> and <code>entity</code>:</p>
<pre class="highlight text">type ComplexType(entity, value, record, number, text, version, os) = 
    member this.Entity  = entity
    member this.Value   = value
    member this.Record  = record
    member this.Number  = number
    member this.Text    = text
    member this.Version = version
    member this.OS      = os
</pre>
<p><strong>Context</strong></p>

<p>The <code>record</code> is a simple aggregate of named values (an F# Record type) with an explicit implementation of <code>Equals</code> and no auto-generated comparisons:</p>
<pre class="highlight text">[&lt;CustomEquality; NoComparison&gt;]
type StructuralType =
    { Value: int;
      Other: string } 

    override this.Equals(y) =
        match y with
        | :? StructuralType as other -&gt; (this.Value = other.Value)
        | _ -&gt; false

    override x.GetHashCode() = hash x.Value
</pre>
<p>The <code>value</code> follows <strong>value semantics</strong> and has no conceptual identity:</p>
<pre class="highlight text">type ValueObject(x: int, y: int) =
    member this.X = x
    member this.Y = y

    override this.Equals(other) =  
        match other with 
        | :? ValueObject as other -&gt; 
            this.X = other.X &amp;&amp; 
            this.Y = other.Y
        | _  -&gt; Object.Equals(this, other)

    override this.GetHashCode() = 
        hash this.X ^^^ 
        hash this.Y
</pre>
<p>The <code>entity</code> type has a <strong>conceptual identity</strong> as the following (rather incomplete) implementation demonstrates:</p>
<pre class="highlight text">type Entity(name: string) = 
    member this.Name = name
    member this.Id   = Guid.NewGuid()

    override this.Equals(other) = 
        match other with
        | :? Entity as other -&gt; this.Id = other.Id
        | _  -&gt; Object.Equals(this, other)

    override this.GetHashCode() = hash this.Id
</pre>
<p>The remaining types are defined in BCL: <code>version</code> overrides its Equals method using value semantics while <code>os</code> represents instances of the <code>OperatingSystem</code> type which uses its default reference equality.</p>

<p><strong>Sample test data</strong></p>

<p>All the following tests are parameterized with xUnit.net&#39;s <code>[&lt;PropertyData&gt;]</code> attribute which means that the test data is coming from a property.</p>

<p>The property below yields <strong>3</strong> tests cases:</p>
<pre class="highlight text">let RecursiveComparisonTestCases : seq&lt;obj[]&gt; = 
    seq {
            yield 
                [| 
                    ComplexType(
                        Entity(&quot;abc&quot;),
                        ValueObject(1, 2),
                        { Value = 1; 
                          Other = &quot;foo&quot; },
                        1,
                        &quot;Anonymous Text&quot;,
                        Version(4, 0, 0),
                        OperatingSystem(
                            PlatformID.Unix,
                            Version(3, 9, 8)))

                    ComplexType(
                        Entity(&quot;abc&quot;),
                        ValueObject(1, 2),
                        { Value = 1; 
                          Other = &quot;bar&quot; },     // Difference
                        1,
                        &quot;Anonymous Text&quot;,
                        Version(4, 0, 0),
                        OperatingSystem(
                            PlatformID.Xbox,   // Difference
                            Version(3, 9, 8)))

                    true // Expected result
                |]

            yield 
                [| 
                    ComplexType(
                        Entity(&quot;abc&quot;),
                        ValueObject(1, 2),
                        { Value = 2;
                          Other = &quot;foo&quot; },
                        1,
                        &quot;123&quot;,
                        Version(4, 0, 0),
                        OperatingSystem(
                            PlatformID.Unix,
                            Version(3, 9, 8)))

                    ComplexType(
                        Entity(&quot;ABC&quot;),         // Difference
                        ValueObject(1, 2),
                        { Value = 2;
                          Other = &quot;foo&quot; },
                        1,
                        &quot;123&quot;,
                        Version(4, 0, 0),
                        OperatingSystem(
                            PlatformID.Xbox,   // Difference
                            Version(3, 9, 8)))

                    true // Expected result
                |]

            yield 
                [| 
                    ComplexType(
                        Entity(&quot;abc&quot;),
                        ValueObject(1, 2),
                        { Value = 3;
                          Other = &quot;foo&quot; },
                        1,
                        &quot;Anonymous Text&quot;,
                        Version(4, 0, 0),
                        OperatingSystem(
                            PlatformID.Unix,
                            Version(3, 9, 8)))

                    ComplexType(
                        Entity(&quot;abc&quot;),
                        ValueObject(1, 2),
                        { Value = 4;           // Difference
                          Other = &quot;foo&quot; },
                        1,
                        &quot;Anonymous Text&quot;,
                        Version(4, 0, 0),
                        OperatingSystem(
                            PlatformID.Xbox,   // Difference
                            Version(0, 0, 0))) // Difference

                    false // Expected result
                |] }
</pre>
<p><strong>Approach</strong></p>

<p>Semantic equality can be modeled with <a href="https://github.com/AutoFixture/AutoFixture/blob/master/Src/SemanticComparison/SemanticComparer.cs#L175">SemanticComparer</a>, as the following parameterized xUnit.net test demonstrates:</p>
<pre class="highlight text">[&lt;Theory; PropertyData(&quot;RecursiveComparisonTestCases&quot;)&gt;]
let ``Equals returns correct result for ComplexType`` value other expected =

    // Fixture setup
    let valueObjectComparer() = { 
        new IMemberComparer with 
            member this.IsSatisfiedBy(request: PropertyInfo) = true
            member this.IsSatisfiedBy(request: FieldInfo) = true
            member this.GetHashCode(obj) = hash obj
            member this.Equals(x, y) = x.Equals(y) }

    let entityComparer() = { 
        new IMemberComparer with 
            member this.IsSatisfiedBy(request: PropertyInfo) = 
                request.PropertyType = typedefof&lt;Entity&gt;
            member this.IsSatisfiedBy(request: FieldInfo) = 
                request.FieldType = typedefof&lt;Entity&gt;
            member this.GetHashCode(obj) = hash obj
            member this.Equals(x, y) = 
                StringComparer.OrdinalIgnoreCase.Equals(
                    (x :?&gt; Entity).Name, 
                    (y :?&gt; Entity).Name) }

    let osComparer() = { 
        new IMemberComparer with 
            member this.IsSatisfiedBy(request: PropertyInfo) = 
                request.PropertyType = typedefof&lt;OperatingSystem&gt;
            member this.IsSatisfiedBy(request: FieldInfo) = 
                request.FieldType = typedefof&lt;OperatingSystem&gt;
            member this.GetHashCode(obj) = hash obj
            member this.Equals(x, y) = 
                (x :?&gt; OperatingSystem).Version.Equals(
                 (y :?&gt; OperatingSystem).Version) }

    let sut = 
        SemanticComparer&lt;ComplexType&gt;(
            valueObjectComparer(), 
            entityComparer(), 
            osComparer())

    // Exercise system
    let actual = sut.Equals(value, other)

    // Verify outcome
    Assert.Equal(expected, actual)

    // Teardown
</pre>
<p><strong>How it works</strong></p>

<ul>
<li><code>SemanticComparer&lt;T&gt;</code> is a boolean &#39;AND&#39; composite over <a href="https://github.com/AutoFixture/AutoFixture/blob/master/Src/SemanticComparison/IMemberComparer.cs">IMemberComparer</a> instances.</li>
<li>It uses <code>valueObjectComparer</code> for everything <strong>except</strong> <code>entity</code> (where it uses <code>entityComparer</code>) and <code>os</code> (where it uses <code>osComparer</code>).</li>
<li>For each property and field, it finds the appropriate <code>IsSatisfiedBy</code> method of the appropriate <code>IMemberComparer</code> instance, and then invokes its <code>Equals</code> method.</li>
</ul>

<p><strong>Packing into a test-specific Equality Assertion</strong></p>

<p>The described behavior can be also packed into a <a href="http://xunitpatterns.com/Custom%20Assertion.html">Custom Assertion</a>. </p>

<p>The idiomatic way of turning a Custom Assertion into a test-specific override of an object&#39;s equality method is called <a href="http://blog.ploeh.dk/2012/06/21/TheResemblanceidiom/">Resemblance</a>.</p>

<p>A Resemblance <a href="http://nikosbaxevanis.com/blog/2012/02/20/dynamic-proxy-overriding-equals-in-autofixture-likeness/">can be emitted dynamically</a> as the following test demonstrates:</p>
<pre class="highlight text">[&lt;Theory; PropertyData(&quot;RecursiveComparisonTestCases&quot;)&gt;]
let ``Likeness returns correct result for ComplexType`` value other expected =

    // (Same setup code as above.)

    let likeness = 
        Likeness&lt;ComplexType&gt;(
            value, 
            SemanticComparer&lt;ComplexType&gt;(
                valueObjectComparer(),
                entityComparer(),
                osComparer()))

    let sut = likeness.ToResemblance()

    // Exercise system
    let actual = sut.Equals(other)

    // Verify outcome
    Assert.Equal(expected, actual)

    // Teardown
</pre>
<p><strong>Running the tests</strong></p>

<p>The tests require SemanticComparison and xUnit.net data theories. Both can be installed through NuGet:</p>
<pre class="highlight text">PM&gt; Install-Package SemanticComparison
PM&gt; Install-Package Xunit.Extensions
</pre>
<p>For added convinience all the above code is also stored in a <a href="https://gist.github.com/moodmosaic/7838293">Gist</a>.</p>
</div><div><hr /><small>Published in <a href="/category/fsharp/">FSharp</a>, by <a href="/">Nikos Baxevanis</a>.</small></div></div><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-24262928-1']);
_gaq.push(['_trackPageview']);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></body></html>