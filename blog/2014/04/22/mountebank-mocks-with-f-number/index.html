<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="Nikos Baxevanis: Full-stack programmer working on small as well as big projects using test-driven development." name="Description" /><title>mountebank mocks with F#</title><link href="/stylesheets/styles.css?1402996835" media="screen" rel="stylesheet" type="text/css" /></head><body><div><div><h1>mountebank mocks with F#</h1><div>April 22, 2014</div></div><div><p><em>This post describes how to use mountebank imposters as Mock Objects/Test Spies via HTTP with F#.</em></p>

<p><em>As a learning exercise, for mountebank, but also for F#, I wrote a few F# functions to communicate with mountebank imposters via HTTP and a few passing tests. The rest of the post describes what I learned so far.</em></p>

<h3>What is mountebank?</h3>

<p><strong>mountebank</strong> is a tool (and currently the only one) which provides multi-protocol, multi-language, on-demand, <a href="http://xunitpatterns.com/Test%20Double.html">Test Doubles</a> over the wire, named <strong>imposters</strong>.</p>

<p>Imposters are normally created during the <a href="http://xunitpatterns.com/fixture%20setup.html">fixture setup</a> phase and disposed in the <a href="http://xunitpatterns.com/fixture%20teardown.html">fixture teardown</a> phase.</p>

<p>According to the <a href="http://www.mbtest.org/">official website</a>, mountebank currently supports imposters for:</p>

<ul>
<li>http</li>
<li>https</li>
<li>tcp</li>
<li>smtp</li>
</ul>

<h3>Smtp example</h3>

<p>Imposters can act as Mocks, as well as Stubs. For Mocks, the mountebank website contains a <a href="http://www.mbtest.org/docs/api/mocks">mocking example</a> for the STMP protocol.</p>

<p><strong>Scenario: SMTP client transmits a mail message; verify the subject of the message.</strong></p>

<p>The mountebank server runs at 192.168.1.3 on port 2525 in a Unix-like OS. During the setup phase an imposter is created via HTTP POST specifying the SMTP protocol and port (4547) in the request body:</p>
<pre class="highlight text">POST http://192.168.1.3:2525/imposters/ HTTP/1.1
Host: 192.168.1.3:2525
Accept: application/json
Content-Type: application/json

{ 
  &quot;port&quot;: 4547, 
  &quot;protocol&quot;: &quot;smtp&quot; 
}
</pre>
<p>In F# this can be written using the <a href="http://fsharp.github.io/FSharp.Data/index.html">FSharp.Data</a> <a href="http://fsharp.github.io/FSharp.Data/library/Http.html">Http</a> module as:</p>
<pre class="highlight text">let Create protocol host port =
    Http.Request(
        &quot;http://&quot; + host + &quot;:2525/imposters/&quot;,
        headers = 
            [&quot;Content-Type&quot;, HttpContentTypes.Json; 
             &quot;Accept&quot;      , HttpContentTypes.Json],
        httpMethod = &quot;POST&quot;,
        body = TextRequest 
                   (sprintf @&quot;{ &quot;&quot;port&quot;&quot;: %i, &quot;&quot;protocol&quot;&quot;: &quot;&quot;%s&quot;&quot; }&quot; 
                       port protocol))
</pre>
<p>The response is:</p>
<pre class="highlight text">HTTP/1.1 201 Created
Location: http://192.168.1.3:2525/imposters/4547
Content-Type: application/json; charset=utf-8
Content-Length: 167
Date: Mon, 21 Apr 2014 20:42:57 GMT
Connection: keep-alive

{
  &quot;protocol&quot;: &quot;smtp&quot;,
  &quot;port&quot;: 4547,
  &quot;requests&quot;: [],
  &quot;stubs&quot;: [],
  &quot;_links&quot;: {
    &quot;self&quot;: {
      &quot;href&quot;: &quot;http://192.168.1.3:2525/imposters/4547&quot;
    }
  }
}
</pre>
<p>Now we can send a mail message via SMTP to the mountebank imposter using port 4547:</p>
<pre class="highlight text">From: &quot;Customer Service&quot; &lt;code@nikosbaxevanis.com&gt;
To: &quot;Customer&quot; &lt;nikos.baxevanis@gmail.com&gt;
Subject: Thank you for your order

Hello Customer,
Thank you for your order from company.com.  Your order will
be shipped shortly.

Your friendly customer service department.
</pre>
<p>In F# this can be written as:</p>
<pre class="highlight text">let expectedSubject = &quot;Thank you for your order&quot;
(new SmtpClient(&quot;192.168.1.3&quot;, 4547)).Send(
    new MailMessage(
        &quot;code@nikosbaxevanis.com&quot;, 
        &quot;nikos.baxevanis@gmail.com&quot;, 
        expectedSubject, 
        &quot;Hello Customer, Thank you for your order from company.com.&quot;))
</pre>
<p>To get the captured requests from the imposter we can issue a <code>GET</code> or a <code>DELETE</code> request. Normally, this happens during the fixture teardown phase via <code>DELETE</code>:</p>
<pre class="highlight text">DELETE http://192.168.1.3:2525/imposters/4547 HTTP/1.1
Content-Type: application/json
Host: 192.168.1.3:2525
</pre>
<blockquote>
<p>According to <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.7">Hypertext Transfer Protocol &ndash; HTTP/1.1</a> for HTTP method definitions, it is OK to issue a DELETE to also get the captured requests from the imposter: <em>&ldquo;A successful response SHOULD be 200 (OK) if the response includes an entity describing the status&rdquo; &ndash; Hypertext Transfer Protocol &ndash; HTTP/1.1, 9.7 DELETE</em>.</p>
</blockquote>

<p>The response is:</p>
<pre class="highlight text">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 810
Date: Mon, 21 Apr 2014 20:41:10 GMT
Connection: keep-alive

{
  &quot;protocol&quot;: &quot;smtp&quot;,
  &quot;port&quot;: 4547,
  &quot;requests&quot;: [
    {
      &quot;requestFrom&quot;: &quot;192.168.1.4&quot;,
      &quot;envelopeFrom&quot;: &quot;code@nikosbaxevanis.com&quot;,
      &quot;envelopeTo&quot;: [
        &quot;nikos.baxevanis@gmail.com&quot;
      ],
      &quot;from&quot;: {
        &quot;address&quot;: &quot;code@nikosbaxevanis.com&quot;,
        &quot;name&quot;: &quot;&quot;
      },
      &quot;to&quot;: [
        {
          &quot;address&quot;: &quot;nikos.baxevanis@gmail.com&quot;,
          &quot;name&quot;: &quot;&quot;
        }
      ],
      &quot;cc&quot;: [],
      &quot;bcc&quot;: [],
      &quot;subject&quot;: &quot;Thank you for your order!&quot;,
      &quot;priority&quot;: &quot;normal&quot;,
      &quot;references&quot;: [],
      &quot;inReplyTo&quot;: [],
      &quot;text&quot;: &quot;Hello Customer, Thank you for your order from company.com.\n&quot;,
      &quot;html&quot;: &quot;&quot;,
      &quot;attachments&quot;: []
    }
  ],
  &quot;stubs&quot;: [],
  &quot;_links&quot;: {
    &quot;self&quot;: {
      &quot;href&quot;: &quot;http://192.168.1.3:2525/imposters/4547&quot;
    }
  }
</pre>
<p>In F# the <code>requests</code> JSON property can be decomposed and extracted using the FSharp.Data <a href="http://fsharp.github.io/FSharp.Data/library/JsonValue.html">JSON Parser</a> and Http modules as:</p>
<pre class="highlight text">let GetCapturedRequests (spy : HttpResponse) = 
    let getRequests jsonValue = 
        match jsonValue with
        | FSharp.Data.Record properties -&gt;
            match properties with
            | [| protocol; port; requests; stubs; _links; |] -&gt;
                match snd requests with
                | FSharp.Data.Array elements -&gt;
                    match elements |&gt; Seq.toList with
                    | head :: tail -&gt; Some(elements)
                    | [] -&gt; None
                | _ -&gt; None
            | _ -&gt; None
        | _ -&gt; None
    let response = 
        Http.Request(
            spy.Headers.Item &quot;Location&quot;,
            headers = [ 
                &quot;Content-Type&quot;, HttpContentTypes.Json; 
                &quot;Accept&quot;, HttpContentTypes.Json ],
            httpMethod = &quot;DELETE&quot;)
    match response.Body with
    | Text json -&gt; 
        JsonValue.Parse json 
        |&gt; getRequests
    | _ -&gt; None
</pre>
<p>The signature of <code>GetCapturedRequests</code> function is:</p>
<pre class="highlight text">spy : HttpResponse -&gt; JsonValue [] option
</pre>
<p>The value of the <code>subject</code> property can be similarly decomposed and extracted with Pattern Matching:</p>
<pre class="highlight text">match GetCapturedRequest imposter &quot;subject&quot; with
| Some actual -&gt; expectedSubject = actual
| None -&gt; 
    raise &lt;| InvalidOperationException(
        &quot;No property named 'subject' found in captured requests.&quot;) 
</pre>
<p>With all the above a test using <a href="https://github.com/xunit/xunit">xUnit.net</a> and <a href="http://blog.ploeh.dk/2014/03/21/composed-assertions-with-unquote/">composed assertions with Unquote</a> could be written as:</p>
<pre class="highlight text">let verify = Swensen.Unquote.Assertions.test

[&lt;Fact&gt;]
let SendMailTransmitsCorrectSubject () =
    let expectedSubject = &quot;Thank you for your order!&quot;
    let mountebankHost = &quot;192.168.1.3&quot;
    let imposterPort = 4547
    let spy = Imposter.Create &quot;smtp&quot; mountebankHost imposterPort

    (new SmtpClient(mountebankHost, imposterPort)).Send(
        new MailMessage(
            &quot;code@nikosbaxevanis.com&quot;, 
            &quot;nikos.baxevanis@gmail.com&quot;, 
            expectedSubject, 
            &quot;Hello Customer, Thank you for your order from company.com.&quot;))

    verify &lt;@
            match SmtpSpy.GetCapturedRequest spy &quot;subject&quot; with
            | Some actual -&gt; expectedSubject = actual
            | None        -&gt; 
                raise &lt;| InvalidOperationException(
                    &quot;No property named 'subject' found in captured requests.&quot;) @&gt;
</pre>
<blockquote>
<p>The mountebank website uses the <a href="http://xunitpatterns.com/Mock%20Object.html">Mock Object</a> terminology when verifying <a href="http://xunitpatterns.com/indirect%20output.html">indirect outputs</a>. However, the examples shown here don&#39;t setup expectations - instead they only verify <em>captured</em>-indirect outputs of the SUT; thus the <a href="http://xunitpatterns.com/Test%20Spy.html">Test Spy</a> terminology is used in code.</p>
</blockquote>

<p><strong>Scenario: SMTP client transmits correct number of requests.</strong></p>

<p>In this case, it&#39;s only necessary to verify that the SMTP request on the imposter was made only once:</p>
<pre class="highlight text">[&lt;Fact&gt;]
let SendMailTransmitsCorrectNumberOfSmtpRequests () =
    let expectedNumberOfRequests = 1
    let mountebankHost = &quot;192.168.1.3&quot;
    let imposterPort = 4546
    let spy = Imposter.Create &quot;smtp&quot; mountebankHost imposterPort

    (new SmtpClient(mountebankHost, imposterPort)).Send(
        new MailMessage(
            &quot;code@nikosbaxevanis.com&quot;, 
            &quot;nikos.baxevanis@gmail.com&quot;, 
            &quot;Thank you for your order!&quot;, 
            &quot;Hello Customer, Thank you for your order from company.com.&quot;))

    verify &lt;@
            match Imposter.GetCapturedRequests spy with
            | Some actual -&gt; expectedNumberOfRequests = (actual |&gt; Seq.length)
            | None -&gt; 
                raise &lt;| InvalidOperationException(
                    sprintf &quot;Expected %i calls but received none.&quot; 
                        expectedNumberOfRequests) @&gt;
</pre>
<p>The complete source code is available on this <a href="https://gist.github.com/moodmosaic/11169180">gist</a> - any comments or suggestions are always welcome.</p>

<p>You may also read the next post, <a href="http://nikosbaxevanis.com/blog/2014/05/02/mountebank-stubs-with-f-number">mountebank stubs with F#</a>.</p>
</div><div><hr /><small>Published in <a href="/category/unit-testing/">Unit Testing</a>, <a href="/category/fsharp/">FSharp</a>, by <a href="/">Nikos Baxevanis</a>.</small></div></div><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-24262928-1']);
_gaq.push(['_trackPageview']);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></body></html>